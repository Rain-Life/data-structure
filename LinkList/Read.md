Tips：
1. 这里不会详细的实现基本的链表，比如插入、删除、查找。只提供这些操作的核心部分(其它各种变形的链表，基本差不多)
2. 对于通过各种类型的链表实现一些经典的问题，会详细分析思路、实现和时间、空间复杂度


## 题目

### 各种类型链表的基本操作

结点的基本结构
```go
package LinkList

//定义结点中数据的类型为接口类型，可收任意类型数据
type Object interface {}

//定义结点的结构体
type Node struct {
 Data Object
 Next *Node
}

//定义链表的结构体
type List struct {
 headNode *Node
}
```

Tip：下边没有考虑特殊情况，比如链表为空，请自行考虑（这里也不写改和查的逻辑，比较简单）

#### 单链表的增删

头插法
```go
newNode.Next = List.HeadNode
List.HeadNode = newNode
```

尾插法
```go
//通过遍历找到最后一个节点（currentNode）
currentNode.Next = newNode
```

在中间某个位置插入节点
```go
//通过循环找到待插入位置的前一个节点(preNode)
newNode.Next = preNode.Next
preNode.Next = newNode
```

删除头结点
```go
//如果链表中只有一个结点
List.HeadNode = nil

//否则
currentNode = List.HeadNode
List.HeadNode = currentNode.Next
```

删除尾节点
```go
//循环遍历链表，找到倒数第二个节点 currentNode
currentNode.Next = nil
```


删除中间的某个节点
```go
//找到待删除结点的前一个结点 preNode
preNode.Next = preNode.Next.Next
```

### 经典题目
1. 单链表实现LRU（Least Recently Used）
2. 通过链表来存储一个字符串，判断这个字符串是不是回文字符串（Palindrome String）
3. 单链表反转（Reverse）
4. 链表中环的检测（Check Ring）
5. 两个有序的链表合并（Merge Order LinkList）
6. 删除单向链表倒数第n个结点（Delete Node）
7. 求链表的中间结点（Find Middle Node）
8. 约瑟夫问题（Joseph Circle）

## 解题思路

### 单链表实现LRU
思路：
现在我实现一个单链表，它越靠后的结点，存的是越少访问的数据。因此，当有一个数据被访问之后，我需要有以下两种情况考虑
1. 如果该数据在单链表中
此时，找到这个结点，并将它从原来的位置删除，然后插入到链表的头部

2. 如果该数据不在单链表中（有两种情况）
如果单链表满了：则删除链表的尾节点，并将该数据插入到链表的头部
如果单链表没满：则直接将该数据插入到单链表头部

### 散列表 + 双向链表 实现LRU
实现思路是和上边一样的，存储结构设计不一样


### 通过链表来存储一个字符串，判断这个字符串是不是回文字符串（Palindrome String）
思路：
利用快慢指针来实现。慢指针一次遍历一个结点，快指针一次遍历两个结点。当快指针遍历到了链表的尾部，此时慢指针就在链表的中间位置
此时将链表的前半部分反转（你也可以反转后半部分），然后对前后两部分的结点进行比较就可以了（文字不好理解，这个一定得画图，方便理解）


### 单链表反转（Reverse）
有两种方法：
1. 就地反转，这个需要利用哨兵的思想，给链表增加一个新的头结点，它不存储数据，每次将最后一个结点插入到这个新的头结点后边
2. 头插法，就是重新创建一个新的链表，将原来链表的每个结点按照头插法，插入到新链表中


### 链表中环的检测（Check Ring）
这个比较简单，利用快慢指针来检测，如果最终快指针能追上慢指针（快慢指针相等），就说明有环


### 两个有序的链表合并（Merge Order LinkList）
两种方法
1. 用一个新的链表保存两者的比较结果，较小的结点，插入到新链表中
2. 利用递归


### 删除单向链表倒数第n个结点（Delete Node）
1. 删除倒数第n个节点，其实就是删除第len-n个节点（len是链表的长度）
2. 删除倒数第N个结点，假设此时有两个指针（快指针fastPtr、慢指针lowPtr）均指向头结点，快指针fastPtr向后遍历N-1个结点之后，慢指针和快指针开始一起向后遍历，当快指针到达最后一个结点的时候，慢指针指向的位置，就是倒数第N个结点的位置


### 求链表的中间结点（Find Middle Node）
快慢指针的方法，当快指针到达链表的尾部了，此时慢指针的位置，就是中间结点


### 约瑟夫问题（Joseph Circle）
用单向的循环链表来保存数字，遍历循环链表，只要没到最后一个结点，就不断的取出结点并重置计数


